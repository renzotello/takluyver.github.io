<?xml version="1.0" encoding="utf-8"?>
<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/"><channel><title>Codel</title><link>http://takluyver.github.io/</link><description>Thoughts about code</description><atom:link href="http://takluyver.github.io/rss.xml" type="application/rss+xml" rel="self"></atom:link><language>en</language><lastBuildDate>Sun, 27 Apr 2014 22:45:29 GMT</lastBuildDate><generator>nikola</generator><docs>http://blogs.law.harvard.edu/tech/rss</docs><item><title>ASTsearch - code searching that knows about code</title><link>http://takluyver.github.io/posts/astsearch-code-searching-that-knows-about-code.html</link><description>&lt;p&gt;This weekend's hack is a tool for searching Python code.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="https://github.com/takluyver/astsearch"&gt;ASTsearch source code on Github&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;What's wrong with grep, you might ask? Let's try to find every division in
IPython's codebase:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ grep --include "*.py" -rF "/" .
config/loader.py:        after applying any insert / extend / update changes
config/configurable.py:                    # ConfigValue is a wrapper for using append / update on containers
config/tests/test_loader.py:        argv = ['--a=~/1/2/3', '--b=~', '--c=~/', '--d="~/"']
config/tests/test_loader.py:        self.assertEqual(config.a, os.path.expanduser('~/1/2/3'))
config/tests/test_loader.py:        self.assertEqual(config.c, os.path.expanduser('~/'))
config/tests/test_loader.py:        self.assertEqual(config.d, '~/')
...
&lt;/pre&gt;
&lt;p&gt;In all, it finds 1685 lines, and very few of them are actual division. You could
write a regex that tries to ignore comments and strings, but &lt;a class="reference external" href="http://regex.info/blog/2006-09-15/247"&gt;now you have two
problems&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Let's do the same with ASTsearch:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
$ astsearch "?/?"
core/oinspect.py
 646|        shalf = int((string_max -5)/2)

core/ultratb.py
1254|        return h / i

core/page.py
 347|        whalf = int((width -5)/2)
...
&lt;/pre&gt;
&lt;p&gt;The output is 89 lines, and when spacing and filenames are removed, there are
46 results, all of which represent division operations.&lt;/p&gt;
&lt;p&gt;In this case, grep produced a lot of false positives. In other cases, it will
have false negatives—results that you wanted but didn't find. &lt;tt class="docutils literal"&gt;a=1&lt;/tt&gt; won't
match &lt;tt class="docutils literal"&gt;a= 1&lt;/tt&gt;, and &lt;tt class="docutils literal"&gt;"this"&lt;/tt&gt; won't match &lt;tt class="docutils literal"&gt;'this'&lt;/tt&gt;. For simple cases, regexes
can help (&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;a\s*=\s*1&lt;/span&gt;&lt;/tt&gt;), but they soon get unwieldy. ASTsearch is insensitive
to how you format your code: even statements split over several lines are easy
to find.&lt;/p&gt;
&lt;div class="section" id="how-does-it-work"&gt;
&lt;h2&gt;How does it work?&lt;/h2&gt;
&lt;p&gt;The string pattern—&lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;?/?&lt;/span&gt;&lt;/tt&gt; in the example above—is turned into an AST pattern.
ASTs, or Abstract Syntax Trees, are a structured representation of a formal
language such as Python source code.&lt;/p&gt;
&lt;p&gt;&lt;tt class="docutils literal"&gt;?&lt;/tt&gt; is a wildcard, so &lt;tt class="docutils literal"&gt;&lt;span class="pre"&gt;?/?&lt;/span&gt;&lt;/tt&gt; means "anything divided by anything". I picked
&lt;tt class="docutils literal"&gt;?&lt;/tt&gt; for this because it's not used in Python syntax, so it doesn't stop you
writing more specific search patterns.&lt;/p&gt;
&lt;p&gt;Some more patterns:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;a = ?&lt;/tt&gt; - Something is assigned to &lt;tt class="docutils literal"&gt;a&lt;/tt&gt;&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;class &lt;span class="pre"&gt;?(TemplateExporter):&lt;/span&gt; ?&lt;/tt&gt; - A subclass of TemplateExporter&lt;/li&gt;
&lt;li&gt;&lt;tt class="docutils literal"&gt;for ? in &lt;span class="pre"&gt;?:&lt;/span&gt; ? \nelse: ?&lt;/tt&gt; - A for loop with an &lt;tt class="docutils literal"&gt;else&lt;/tt&gt; clause&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Then it walks the directory, parsing each file with a &lt;tt class="docutils literal"&gt;.py&lt;/tt&gt; extension using
Python's built in parser. The standard library &lt;a class="reference external" href="https://docs.python.org/3/library/ast.html"&gt;ast module&lt;/a&gt; contains the tools to parse the
code and walk the AST, and &lt;a class="reference external" href="https://pypi.python.org/pypi/astcheck"&gt;astcheck&lt;/a&gt;,
another tool I wrote, can compare AST nodes against a template.&lt;/p&gt;
&lt;p&gt;Besides the command line interface, you can also use ASTsearch as a Python
module (&lt;tt class="docutils literal"&gt;import astsearch&lt;/tt&gt;). It's possible to define complex search patterns
in Python code that can't be written at the command line. &lt;a class="reference external" href="http://astsearch.readthedocs.org/en/latest/api.html"&gt;See the docs&lt;/a&gt; for some more details.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="what-s-the-catch"&gt;
&lt;h2&gt;What's the catch?&lt;/h2&gt;
&lt;p&gt;ASTsearch only works on Python files, and Python files that are entirely valid
syntax (that's Python 3 syntax for now). If just the last line can't be parsed,
it won't find any matches in that file.&lt;/p&gt;
&lt;p&gt;It's slower than grep, because what it's doing is much more complex, and grep is
&lt;a class="reference external" href="http://lists.freebsd.org/pipermail/freebsd-current/2010-August/019310.html"&gt;highly optimised&lt;/a&gt;.
But Python's parser is doing most of the hard work, and that's written in C. On
my laptop, scanning the IPython codebase (about 100k lines of code) takes about
3.5 seconds—definitely not instant, but far faster than I can think about even a
couple of results.&lt;/p&gt;
&lt;p&gt;There are search patterns you can't express at the command line. For instance,
you can't match function calls with a specific number of arguments (but you can
find function &lt;em&gt;definitions&lt;/em&gt; with a given number of arguments: &lt;tt class="docutils literal"&gt;def &lt;span class="pre"&gt;?(?,&lt;/span&gt; &lt;span class="pre"&gt;?):&lt;/span&gt; ?&lt;/tt&gt;).
I might extend the pattern mini-language once I've got a feel for what would be
useful.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="how-do-i-install-it"&gt;
&lt;h2&gt;How do I install it?&lt;/h2&gt;
&lt;pre class="literal-block"&gt;
pip install astsearch
&lt;/pre&gt;
&lt;/div&gt;</description><guid>http://takluyver.github.io/posts/astsearch-code-searching-that-knows-about-code.html</guid><pubDate>Sun, 27 Apr 2014 17:39:44 GMT</pubDate></item><item><title>Readable Python coroutines</title><link>http://takluyver.github.io/posts/readable-python-coroutines.html</link><description>&lt;p&gt;Quick exercise: write a piece of code that, each time you pass it a word (a
string), tells you if you've passed it that word before. If you're reading a
post with a title like this, it shouldn't take you more than a few minutes. For
bonus points, have an option to ignore case, so it counts 'parrot' and 'Parrot'
as the same word.&lt;/p&gt;
&lt;p&gt;What did you go for? A function with a global variable (yuck!)? A class with a
method? A closure?&lt;/p&gt;
&lt;p&gt;How about a coroutine? Here's what that would look like:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;have_seen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case_sensitive&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;seen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;case_sensitive&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;And here's how you would use it:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; hs = have_seen()
&amp;gt;&amp;gt;&amp;gt; next(hs)  # prime it
&amp;gt;&amp;gt;&amp;gt; hs.send('Hello')
False
&amp;gt;&amp;gt;&amp;gt; hs.send('World')
False
&amp;gt;&amp;gt;&amp;gt; hs.send('hello')
True
&lt;/pre&gt;
&lt;p&gt;Coroutines in Python are based on the generator machinery - see the &lt;tt class="docutils literal"&gt;yield&lt;/tt&gt;
keyword in there? &lt;a class="reference external" href="http://www.python.org/dev/peps/pep-0342/"&gt;PEP 342&lt;/a&gt;,
"Coroutines via Enhanced Generators", added the necessary features to Python
2.5, but it's not a very well known part of the language. And it's not hard to
see why - the code above isn't as clear as it should be:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;Emitting and receiving a value happen in the same yield expression. So rather
than yielding the response at the bottom of the loop, we have to store it in a
variable and jump back to the top of the loop.&lt;/li&gt;
&lt;li&gt;The coroutine has to emit a value before it can receive one, even though
there's nothing it really wants to emit. That's why we set &lt;tt class="docutils literal"&gt;res = None&lt;/tt&gt;
before the loop, and why the caller has to prime it by calling &lt;tt class="docutils literal"&gt;next(hs)&lt;/tt&gt;
before using it. It's easy to write a decorator that calls &lt;tt class="docutils literal"&gt;next&lt;/tt&gt; for you,
but that doesn't make the code inside the coroutine any clearer.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So the standard Python syntax is rather awkward. But we can make it clearer by
using a bit of wrapper code.
The trick is separating sending a value from receiving one:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;coromagic&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;

&lt;span class="nd"&gt;@coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;have_seen2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case_sensitive&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;seen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;case_sensitive&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;We no longer need the &lt;cite&gt;res&lt;/cite&gt; variable. Instead, we alternate between two uses of
yield: a receiving yield, where we send the wrapper a token to indicate that
we're ready for a new value, and a sending yield, where we don't expect to get a
value back. The caller can use this in exactly the same way as the original
coroutine, except that the wrapper primes it automatically, so there's no need
to call &lt;tt class="docutils literal"&gt;next(hs)&lt;/tt&gt;.&lt;/p&gt;
&lt;p&gt;The wrapper expects a receiving yield first, and at most one sending yield after
each receiving yield. If a receiving yield is followed by another receiving
yield, without a sending yield inbetween, &lt;tt class="docutils literal"&gt;None&lt;/tt&gt; is returned to the caller,
just like a function without a return statement.&lt;/p&gt;
&lt;div class="section" id="handling-exceptions"&gt;
&lt;h2&gt;Handling exceptions&lt;/h2&gt;
&lt;p&gt;If either of our coroutines above raises an exception, we can't keep using that
coroutine:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; hs.send(12)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
  File "coro_ideas.py", line 8, in have_seen
    word = word.lower()
AttributeError: 'int' object has no attribute 'lower'
&amp;gt;&amp;gt;&amp;gt; hs.send('hi')
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
StopIteration
&lt;/pre&gt;
&lt;p&gt;I've got a solution of sorts for that, although it still feels a bit awkward.
The coroutine can request a context manager to catch exceptions:&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;coromagic&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;get_exception_context&lt;/span&gt;

&lt;span class="nd"&gt;@coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;have_seen3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;case_sensitive&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="bp"&gt;False&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;exception_context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;get_exception_context&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="n"&gt;seen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;set&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;with&lt;/span&gt; &lt;span class="n"&gt;exception_context&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;case_sensitive&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                &lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lower&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;seen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;add&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;word&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;The context manager co-ordinates with the wrapper to suppress the exception inside the coroutine, but raise it to the caller:&lt;/p&gt;
&lt;pre class="literal-block"&gt;
&amp;gt;&amp;gt;&amp;gt; hs3 = have_seen3()
&amp;gt;&amp;gt;&amp;gt; hs3.send(12)
Traceback (most recent call last):
  File "&amp;lt;stdin&amp;gt;", line 1, in &amp;lt;module&amp;gt;
  File "./coromagic.py", line 28, in send
    raise self.last_exc
  File "./coro_ideas.py", line 47, in have_seen3
    word = word.lower()
AttributeError: 'int' object has no attribute 'lower'
&amp;gt;&amp;gt;&amp;gt; hs3.send('hi')
False
&lt;/pre&gt;
&lt;p&gt;Now the error doesn't stop us processing valid input afterwards.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="who-cares-about-coroutines"&gt;
&lt;h2&gt;Who cares about coroutines?&lt;/h2&gt;
&lt;p&gt;I find them interesting on their own. But this isn't just academic -
there are cases where coroutines can be the clearest way to write something.&lt;/p&gt;
&lt;p&gt;The &lt;tt class="docutils literal"&gt;have_seen&lt;/tt&gt; example could easily be written with a class or a closure.
Coroutines come into their own for making state machines. With a class or a
closure, the state has to be stored in a variable, and you need a lookup table
to decide how to behave in each state. A coroutine can store the state as the
point where its code is executing.&lt;/p&gt;
&lt;p&gt;It's hard to come up with an example of this that's both realistic and
short, but here's my attempt. We're writing a plugin for a chat
application, which lets any chatter say "password foo", silencing everyone until
someone guesses "foo". The application just passes us each message, and expects
a True/False response saying whether it should be broadcast.&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="nd"&gt;@coroutine&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;password_game&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="c"&gt;# Normal chatting&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;msg&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;startswith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"password "&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;password&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;9&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;
                &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;
                &lt;span class="k"&gt;break&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;  &lt;span class="c"&gt;# Broadcast&lt;/span&gt;

        &lt;span class="c"&gt;# Waiting for someone to guess the password&lt;/span&gt;
        &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="n"&gt;password&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt; &lt;span class="c"&gt;# Don't send messages&lt;/span&gt;
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;   &lt;span class="c"&gt;# Show everyone the password once it has been guessed&lt;/span&gt;
&lt;/pre&gt;
&lt;p&gt;In IPython, we have some coroutines for input processing. For instance, the
transformer to strip prompts from pasted code processes the first two lines in a
prompt-detection state. Then it moves into a prompt-stripping state if it
detected a prompt, or a no-op state if it didn't.&lt;/p&gt;
&lt;p&gt;The pattern of sending and receiving is also reminiscent of writing a thread
with input and output queues, and waiting for values on those queues. But
threads are messy: you have to deal with synchronisation and shut them
down safely. Calling a cororoutine is as deterministic as calling a function:
it runs, returns a value, and the calling code carries on. Of course, that means
that coroutines themselves don't run in parallel. But you can use them to build
clever things like &lt;a class="reference external" href="http://code.google.com/p/tulip/"&gt;tulip&lt;/a&gt;, which will become
the &lt;tt class="docutils literal"&gt;asyncio&lt;/tt&gt; module in Python 3.4. Tulip can suspend one coroutine and run
others while it waits for data, and then resume it when the data it needs is
ready.&lt;/p&gt;
&lt;p&gt;The best resource on coroutines in Python is &lt;a class="reference external" href="http://dabeaz.com/coroutines/"&gt;this excellent course&lt;/a&gt; by David Beazley.&lt;/p&gt;
&lt;/div&gt;
&lt;div class="section" id="coromagic-source-code"&gt;
&lt;h2&gt;Coromagic source code&lt;/h2&gt;
&lt;p&gt;This is the module used in the examples above.&lt;/p&gt;
&lt;p&gt;&lt;a class="reference external" href="link://listing/coromagic.py"&gt;coromagic.py&lt;/a&gt;&lt;/p&gt;
&lt;pre class="code python literal-block"&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;functools&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;wraps&lt;/span&gt;

&lt;span class="c"&gt;# Tokens&lt;/span&gt;
&lt;span class="n"&gt;receive&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="n"&gt;get_exception_context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;CoroutineWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;last_exc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gen&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;generator&lt;/span&gt;

        &lt;span class="n"&gt;ready&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;ready&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;get_exception_context&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;ready&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ExceptionContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
        &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;ready&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_exc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;

        &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;send&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;res&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;gen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;receive&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_exc&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_exc&lt;/span&gt;

        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;res&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;coroutine&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;genfunc&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="sd"&gt;"""Decorator for a generator function to wrap it as a coroutine."""&lt;/span&gt;
    &lt;span class="nd"&gt;@wraps&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;genfunc&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;wrapped&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;CoroutineWrapper&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;genfunc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt;&lt;span class="n"&gt;kwargs&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;wrapped&lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;ExceptionContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__init__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;corowrapper&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;corowrapper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;corowrapper&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__enter__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;__exit__&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tb&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="nb"&gt;type&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ne"&gt;GeneratorExit&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;False&lt;/span&gt;

        &lt;span class="c"&gt;# Pass other exceptions to the wrapper, and silence them for now&lt;/span&gt;
        &lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;corowrapper&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;last_exc&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="bp"&gt;True&lt;/span&gt;
&lt;/pre&gt;
&lt;/div&gt;</description><guid>http://takluyver.github.io/posts/readable-python-coroutines.html</guid><pubDate>Sun, 10 Nov 2013 14:28:51 GMT</pubDate></item></channel></rss>